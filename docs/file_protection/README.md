# Настройка ограничения доступа к файлам и каталогам

Mount namespaces изолируют ресурсы файловых систем.
Linux только делает копии особых файлов, таких как список точек монтирования, остальные файлы - те же, что у запускающего процесса


Для запуска бинарей в новом неймспейсе, поскольку они могут зависит от ресурсов, вроде файлов операционной системы. 
Нужно предоставить программе собственную копию зависимостей и системных файлов, которые требуются для запуска целиком в "песочнице", чтобы она могла вносить в 
них какие-либо изменения, не влияя на другие программы в системе.

- Можно брать из нашей файловой системы только то, что пригодится - тогда нужно каждый раз анализировать файлы, которые нужны нашему бинарю.
- Можно брать все, что есть в исходной.
- Можно брать уже собранный минимальный набор системных файлов (Alpine Linux - предоставляет корневые файловые системы)

Pivot root - позволяет нам контролировать то, что именно процессы видят как корневую файловую систему.


Делаем следующее:
1.   Создадим копию зависимостей и системных файлов, необходимых команде.
2.   Создадим новый mount namespace.
3.   Заменим корневую файловую систему в новом mount namespace на ту, которая содержит копии наших системных файлов. (или alpine)
4.   Выполним программу в новом mount namespace.


bash версия:

(Флаг -m создаёт новый mount namespace, Linux только делает копии особых файлов, таких как список точек монтирования, остальные файлы - те же, что у запускающего процесса)
```
wget http://dl-cdn.alpinelinux.org/alpine/v3.10/releases/x86_64/alpine-minirootfs-3.10.1-x86_64.tar.gz
mkdir rootfs
tar -xzf alpine-minirootfs-3.10.1-x86_64.tar.gz -C rootfs
unshare -m bash
mount --bind rootfs rootfs
cd rootfs
mkdir put_old
pivot_root . put_old
cd /
umount -l put_old
```

C++
- флаг CLONE_NEWNS для clone.



После этого все файлы в старой файловой системе будут недоступны.



# PID Namespaces
(Something near)

После простого отмонтирования старого корня /proc будет пустым, и чтобы видеть наши процессы - нужно еще действий сделать.

1. Нужно завести файловую систему proc в /proc. 
2. Запустить этот процесс внутри собственного PID namespace.

PID namespace изолирует ID процессов в системе. Одним из следствий тут является то, что выполняющиеся в разных пространствах имён PID процессы могут иметь одинаковые идентификаторы процесса, не конфликтуя друг с другом. 


Новый PID namespace, создается при передаче флага CLONE_NEWPID для clone:

bash:
```
mkdir /proc
chmod 555 /proc
mount -t proc proc /proc
```

И делать это нужно перед отмонтированием старого корня


После этого процесс будет считать себя единственным процессом, запущенным в системе и работающем с PID 1



Cсылки :
- https://man7.org/linux/man-pages/man2/clone.2.html
- https://man7.org/linux/man-pages/man2/pivot_root.2.htmlc
- https://habr.com/ru/post/458462/
- https://github.com/iffyio/isolate/blob/part-3/isolate.c (пример кода с реализацией всех этих действий)

